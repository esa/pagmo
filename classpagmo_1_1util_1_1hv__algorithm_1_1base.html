<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PaGMO: pagmo::util::hv_algorithm::base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PaGMO
   &#160;<span id="projectnumber">1.1.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepagmo.html">pagmo</a></li><li class="navelem"><a class="el" href="namespacepagmo_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacepagmo_1_1util_1_1hv__algorithm.html">hv_algorithm</a></li><li class="navelem"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">pagmo::util::hv_algorithm::base Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base hypervolume class.  
 <a href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="util_2hv__algorithm_2base_8h_source.html">base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pagmo::util::hv_algorithm::base:</div>
<div class="dyncontent">
<div class="center"><img src="classpagmo_1_1util_1_1hv__algorithm_1_1base__inherit__graph.png" border="0" usemap="#pagmo_1_1util_1_1hv__algorithm_1_1base_inherit__map" alt="Inheritance graph"/></div>
<map name="pagmo_1_1util_1_1hv__algorithm_1_1base_inherit__map" id="pagmo_1_1util_1_1hv__algorithm_1_1base_inherit__map">
<area shape="rect" id="node2" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__approx.html" title="Bringmann&#45;Friedrich approximation method. " alt="" coords="236,5,404,47"/><area shape="rect" id="node3" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html" title="Bringmann&#45;Friedrich approximation method. " alt="" coords="236,71,404,112"/><area shape="rect" id="node4" href="classpagmo_1_1util_1_1hv__algorithm_1_1fpl.html" title="fpl hypervolume algorithm " alt="" coords="225,137,415,163"/><area shape="rect" id="node5" href="classpagmo_1_1util_1_1hv__algorithm_1_1hoy.html" title="HOY algorithm. " alt="" coords="221,187,419,214"/><area shape="rect" id="node6" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv2d.html" title="hv2d hypervolume algorithm class " alt="" coords="236,239,404,280"/><area shape="rect" id="node7" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv3d.html" title="hv3d hypervolume algorithm class " alt="" coords="236,304,404,345"/><area shape="rect" id="node8" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv4d.html" title="hv4d hypervolume algorithm " alt="" coords="236,369,404,411"/><area shape="rect" id="node9" href="classpagmo_1_1util_1_1hv__algorithm_1_1wfg.html" title="WFG hypervolume algorithm. " alt="" coords="221,435,419,462"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f2fa7e0074b2f4da4f7af58e2ee9e56"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a6f2fa7e0074b2f4da4f7af58e2ee9e56">compute</a> (std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;points, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;r_point) const =0</td></tr>
<tr class="memdesc:a6f2fa7e0074b2f4da4f7af58e2ee9e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute method.  <a href="#a6f2fa7e0074b2f4da4f7af58e2ee9e56">More...</a><br /></td></tr>
<tr class="separator:a6f2fa7e0074b2f4da4f7af58e2ee9e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230011c2b5274a2e20060cdb10fe2aec"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a230011c2b5274a2e20060cdb10fe2aec">exclusive</a> (const unsigned int, std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;) const </td></tr>
<tr class="memdesc:a230011c2b5274a2e20060cdb10fe2aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclusive hypervolume method.  <a href="#a230011c2b5274a2e20060cdb10fe2aec">More...</a><br /></td></tr>
<tr class="separator:a230011c2b5274a2e20060cdb10fe2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e6e044ab111e4eeec6bfab750f5e6a"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a24e6e044ab111e4eeec6bfab750f5e6a">least_contributor</a> (std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;) const </td></tr>
<tr class="memdesc:a24e6e044ab111e4eeec6bfab750f5e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least contributor method.  <a href="#a24e6e044ab111e4eeec6bfab750f5e6a">More...</a><br /></td></tr>
<tr class="separator:a24e6e044ab111e4eeec6bfab750f5e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6819dc695fb462804edc56aa48a28b34"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a6819dc695fb462804edc56aa48a28b34">greatest_contributor</a> (std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;) const </td></tr>
<tr class="memdesc:a6819dc695fb462804edc56aa48a28b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest contributor method.  <a href="#a6819dc695fb462804edc56aa48a28b34">More...</a><br /></td></tr>
<tr class="separator:a6819dc695fb462804edc56aa48a28b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffca60efe32aa257c8d2412a1c7a0f1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#acffca60efe32aa257c8d2412a1c7a0f1">contributions</a> (std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;) const </td></tr>
<tr class="memdesc:acffca60efe32aa257c8d2412a1c7a0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contributions method.  <a href="#acffca60efe32aa257c8d2412a1c7a0f1">More...</a><br /></td></tr>
<tr class="separator:acffca60efe32aa257c8d2412a1c7a0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd91d67087f9d26a50c91e4fb35cac7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#acfd91d67087f9d26a50c91e4fb35cac7">verify_before_compute</a> (const std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;points, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;r_point) const =0</td></tr>
<tr class="memdesc:acfd91d67087f9d26a50c91e4fb35cac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verification of input.  <a href="#acfd91d67087f9d26a50c91e4fb35cac7">More...</a><br /></td></tr>
<tr class="separator:acfd91d67087f9d26a50c91e4fb35cac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196075e7a9526aa217b5c96e1f7044f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepagmo_1_1util_1_1hv__algorithm.html#a90193639f7a1703c47c6ebecff50c2f6">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a196075e7a9526aa217b5c96e1f7044f2">clone</a> () const =0</td></tr>
<tr class="memdesc:a196075e7a9526aa217b5c96e1f7044f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone method.  <a href="#a196075e7a9526aa217b5c96e1f7044f2">More...</a><br /></td></tr>
<tr class="separator:a196075e7a9526aa217b5c96e1f7044f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c3c236fe354e8c8b6c3547d9a0db60"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a08c3c236fe354e8c8b6c3547d9a0db60">get_name</a> () const </td></tr>
<tr class="memdesc:a08c3c236fe354e8c8b6c3547d9a0db60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get algorithm's name.  <a href="#a08c3c236fe354e8c8b6c3547d9a0db60">More...</a><br /></td></tr>
<tr class="separator:a08c3c236fe354e8c8b6c3547d9a0db60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec838f9cb362430fd30e5137a089e313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec838f9cb362430fd30e5137a089e313"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#aec838f9cb362430fd30e5137a089e313">~base</a> ()</td></tr>
<tr class="memdesc:aec838f9cb362430fd30e5137a089e313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor required for pure virtual methods. <br /></td></tr>
<tr class="separator:aec838f9cb362430fd30e5137a089e313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a43087efbc5e82e07da068a5e7a94513c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a43087efbc5e82e07da068a5e7a94513c">volume_between</a> (const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;, unsigned int=0)</td></tr>
<tr class="memdesc:a43087efbc5e82e07da068a5e7a94513c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute volume between two points.  <a href="#a43087efbc5e82e07da068a5e7a94513c">More...</a><br /></td></tr>
<tr class="separator:a43087efbc5e82e07da068a5e7a94513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a89a3a2ee9001c55e03eb62f5ad30f0af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89a3a2ee9001c55e03eb62f5ad30f0af"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>DOM_CMP_B_DOMINATES_A</b> = 1, 
<b>DOM_CMP_A_DOMINATES_B</b> = 2, 
<b>DOM_CMP_A_B_EQUAL</b> = 3, 
<b>DOM_CMP_INCOMPARABLE</b> = 4
 }</td></tr>
<tr class="separator:a89a3a2ee9001c55e03eb62f5ad30f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adac5b5572ce843f8b77594a7254d20db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#adac5b5572ce843f8b77594a7254d20db">assert_minimisation</a> (const std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;) const </td></tr>
<tr class="memdesc:adac5b5572ce843f8b77594a7254d20db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that reference point dominates every other point from the set.  <a href="#adac5b5572ce843f8b77594a7254d20db">More...</a><br /></td></tr>
<tr class="separator:adac5b5572ce843f8b77594a7254d20db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f32a88f43e2052cc5b9efe420c833a"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a44f32a88f43e2052cc5b9efe420c833a">extreme_contributor</a> (std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;, bool(*)(double, double)) const </td></tr>
<tr class="memdesc:a44f32a88f43e2052cc5b9efe420c833a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the extreme contributor  <a href="#a44f32a88f43e2052cc5b9efe420c833a">More...</a><br /></td></tr>
<tr class="separator:a44f32a88f43e2052cc5b9efe420c833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a1cb0765787f1c2a3589054a74365b0c9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a1cb0765787f1c2a3589054a74365b0c9">cmp_least</a> (const double, const double)</td></tr>
<tr class="memdesc:a1cb0765787f1c2a3589054a74365b0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison method for the least contributor.  <a href="#a1cb0765787f1c2a3589054a74365b0c9">More...</a><br /></td></tr>
<tr class="separator:a1cb0765787f1c2a3589054a74365b0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a33cec3824b5b2c13a2dfebdbab1d7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a67a33cec3824b5b2c13a2dfebdbab1d7">cmp_greatest</a> (const double, const double)</td></tr>
<tr class="memdesc:a67a33cec3824b5b2c13a2dfebdbab1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison method for the least contributor.  <a href="#a67a33cec3824b5b2c13a2dfebdbab1d7">More...</a><br /></td></tr>
<tr class="separator:a67a33cec3824b5b2c13a2dfebdbab1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9272bf3b4f1787e3278984e55291c0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a9f9272bf3b4f1787e3278984e55291c0">volume_between</a> (double *, double *, unsigned int)</td></tr>
<tr class="memdesc:a9f9272bf3b4f1787e3278984e55291c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute volume between two points.  <a href="#a9f9272bf3b4f1787e3278984e55291c0">More...</a><br /></td></tr>
<tr class="separator:a9f9272bf3b4f1787e3278984e55291c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765957fc1f45fe80210c16cb22bf0fcc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a765957fc1f45fe80210c16cb22bf0fcc">dom_cmp</a> (double *, double *, unsigned int)</td></tr>
<tr class="memdesc:a765957fc1f45fe80210c16cb22bf0fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dominance comparison method.  <a href="#a765957fc1f45fe80210c16cb22bf0fcc">More...</a><br /></td></tr>
<tr class="separator:a765957fc1f45fe80210c16cb22bf0fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d9f901aa45a780cb09f440642cb54e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a98d9f901aa45a780cb09f440642cb54e">dom_cmp</a> (const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;, const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;, unsigned int=0)</td></tr>
<tr class="memdesc:a98d9f901aa45a780cb09f440642cb54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dominance comparison method.  <a href="#a98d9f901aa45a780cb09f440642cb54e">More...</a><br /></td></tr>
<tr class="separator:a98d9f901aa45a780cb09f440642cb54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base hypervolume class. </p>
<p>This class represents the abstract hypervolume algorithm used for computing the hypervolume indicator (also known as Lebesgue measure, or S-metric), and other measures that can derive from it, e.g. exclusive contribution by given point</p>
<p>The are few public methods available:</p>
<ul>
<li>'compute' - returns the total hypervolume of the set of points</li>
<li>'exclusive' - returns the exclusive volume contributed by given point</li>
<li>'least_contributor' - returns an index of the point contributing the least volume</li>
<li>'greatest_contributor' - returns an index of the point contributing the most volume</li>
<li>'contributions' - returns a vector of exclusive contributions by each of the points.</li>
</ul>
<p>Additionally a private method '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a44f32a88f43e2052cc5b9efe420c833a" title="compute the extreme contributor ">base::extreme_contributor</a>' can be overloaded:</p><ul>
<li>'extreme_contributor' - returns an index of a single individual that contributes either the least or the greatest amount of the volume. The distinction between the extreme contributors is made using a comparator function. Purpose of this method is to avoid repeating a similar code for the least and the greatest contributor methods. In many cases it's just a matter of a single alteration in a comparison sign '&lt;' to '&gt;'. See concrete example here for more details.</li>
</ul>
<p>The following base class provides an interface for any <a class="el" href="namespacepagmo_1_1util_1_1hv__algorithm.html" title="Hypervolume algorithm namespace. ">hv_algorithm</a> that may be added. The crucial method to implement is the 'compute' method, as the remaining methods can be derived from it.</p>
<p>Base class assumes that the <a class="el" href="namespacepagmo_1_1util_1_1hv__algorithm.html" title="Hypervolume algorithm namespace. ">hv_algorithm</a> implements the 'compute' method, and employs a naive approach to provide other functionalities:</p>
<p>'<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a230011c2b5274a2e20060cdb10fe2aec" title="Exclusive hypervolume method. ">base::exclusive</a>' method relies on 'compute' method, by computing the hypervolume twice (e.g. ExclusiveHV = HV(P) - HV(P/{p})) '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#acffca60efe32aa257c8d2412a1c7a0f1" title="Contributions method. ">base::contributions</a>' method relies on 'compute' method as well, by computing the exclusive volume for each point using approach above. '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a44f32a88f43e2052cc5b9efe420c833a" title="compute the extreme contributor ">base::extreme_contributor</a>' (private method) relies on the '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#acffca60efe32aa257c8d2412a1c7a0f1" title="Contributions method. ">base::contributions</a>' method in order to elicit the correct extreme individual. '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a24e6e044ab111e4eeec6bfab750f5e6a" title="Least contributor method. ">base::least_contributor</a>' and '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a6819dc695fb462804edc56aa48a28b34" title="Greatest contributor method. ">base::greatest_contributor</a>' methods rely on '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a44f32a88f43e2052cc5b9efe420c833a" title="compute the extreme contributor ">base::extreme_contributor</a>' method by providing the correct comparator.</p>
<p>Thanks to that, any newly implemented hypervolume algorithm that overloads the 'compute' method, gets the functionalities above as well. It is often the case that the algorithm may provide a better solution for each of the features above, e.g. overloading the '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#a44f32a88f43e2052cc5b9efe420c833a" title="compute the extreme contributor ">base::extreme_contributor</a>' method with an efficient solution, will automatically speed up the 'least_contributor' and the 'greatest_contributor' methods as well.</p>
<p>Additionally, any newly implemented hypervolume algorithm should overload the '<a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1base.html#acfd91d67087f9d26a50c91e4fb35cac7" title="Verification of input. ">base::verify_before_compute</a>' method in order to prevent the computation for the incompatible data.</p>
<dl class="section author"><dt>Author</dt><dd>Krzysztof Nowak (<a href="#" onclick="location.href='mai'+'lto:'+'kn@'+'ki'+'ryx'+'.n'+'et'; return false;">kn@ki<span style="display: none;">.nosp@m.</span>ryx.<span style="display: none;">.nosp@m.</span>net</a>) </dd></dl>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8h_source.html#l00090">90</a> of file <a class="el" href="util_2hv__algorithm_2base_8h_source.html">util/hv_algorithm/base.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adac5b5572ce843f8b77594a7254d20db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pagmo::util::hv_algorithm::base::assert_minimisation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that reference point dominates every other point from the set. </p>
<p>This is a method that can be referenced from verify_before_compute method. The method checks whether the provided reference point fits the minimisation assumption, e.g., reference point must be "no worse" and in at least one objective and "better" for each of the points from the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>- vector of fitness_vectors for which the hypervolume is computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_point</td><td>- distinguished "reference point". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00041">41</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a196075e7a9526aa217b5c96e1f7044f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepagmo_1_1util_1_1hv__algorithm.html#a90193639f7a1703c47c6ebecff50c2f6">base_ptr</a> pagmo::util::hv_algorithm::base::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone method. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacepagmo_1_1util_1_1hv__algorithm.html#a90193639f7a1703c47c6ebecff50c2f6" title="Base hypervolume algorithm class. ">pagmo::util::hv_algorithm::base_ptr</a> to a copy of this. </dd></dl>

<p>Implemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv4d.html#a8c0bb76655cc008c4088037ec80fd73f">pagmo::util::hv_algorithm::hv4d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1fpl.html#aaa168a4d3e4c105fd4ed4dffe193159f">pagmo::util::hv_algorithm::fpl</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hoy.html#a600a43bc4b01688904d583fcbf88c9cf">pagmo::util::hv_algorithm::hoy</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#aa68831fe2d5511ee764c55603c6c0e0e">pagmo::util::hv_algorithm::bf_fpras</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv3d.html#a4ee07b2b0a7f10ff41a38f0fcf048a11">pagmo::util::hv_algorithm::hv3d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__approx.html#aa3d2f36336c506db6befdf4edcbdbca9">pagmo::util::hv_algorithm::bf_approx</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1wfg.html#a39b8f9a2dfac139d7bf436a75d8281a9">pagmo::util::hv_algorithm::wfg</a>, and <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv2d.html#ab65c2485bbd39678dd6439502e9c75d6">pagmo::util::hv_algorithm::hv2d</a>.</p>

</div>
</div>
<a class="anchor" id="a67a33cec3824b5b2c13a2dfebdbab1d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pagmo::util::hv_algorithm::base::cmp_greatest </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison method for the least contributor. </p>
<p>This method is used as a comparison function for the extreme contributor method which may be overloaded by hv algorithms. In such case, this method can determine, given two contributions of points, which one is the "greater" contributor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first contribution of a point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second contribution of a point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contribution 'a' is greater than contribution 'b' </dd></dl>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00150">150</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cb0765787f1c2a3589054a74365b0c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pagmo::util::hv_algorithm::base::cmp_least </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison method for the least contributor. </p>
<p>This method is used as a comparison function for the extreme contributor method which may be overloaded by hv algorithms. In such case, this method can determine, given two contributions of points, which one is the "smaller" contributor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first contribution of a point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second contribution of a point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contribution 'a' is lesser than contribution 'b' </dd></dl>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00134">134</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f2fa7e0074b2f4da4f7af58e2ee9e56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double pagmo::util::hv_algorithm::base::compute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute method. </p>
<p>This method computes the hypervolume. It accepts a list of points as an input, and the distinguished "reference point". Hypervolume is then computed as a joint hypervolume of hypercubes, generated pairwise with the reference point and each point from the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>- vector of fitness_vectors for which the hypervolume is computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_point</td><td>- distinguished "reference point". </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv4d.html#a2c680dd074c7e97bf44f5a07ef245bec">pagmo::util::hv_algorithm::hv4d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hoy.html#a11d672efab5c20ae42df5e78ec4fd39d">pagmo::util::hv_algorithm::hoy</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1fpl.html#a295473a55529dfec4e3d8ae5730de84f">pagmo::util::hv_algorithm::fpl</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv3d.html#a543ce96dea6541d49bfeef9ba9b98bd5">pagmo::util::hv_algorithm::hv3d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__approx.html#aeb47fb85791dcf2481a2293a41c32e40">pagmo::util::hv_algorithm::bf_approx</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#ac2b36d04fb56a1705491f860c5fa9b78">pagmo::util::hv_algorithm::bf_fpras</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1wfg.html#a1105fb9128213514b0a3b7906c8e8fd0">pagmo::util::hv_algorithm::wfg</a>, and <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv2d.html#a330360637b6cdf19918e16da2956cac7">pagmo::util::hv_algorithm::hv2d</a>.</p>

</div>
</div>
<a class="anchor" id="acffca60efe32aa257c8d2412a1c7a0f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; pagmo::util::hv_algorithm::base::contributions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contributions method. </p>
<p>This methods return the exclusive contribution to the hypervolume for each point. Main reason for this method is the fact that in most cases the explicit request for all contributions can be done more efficiently (may vary depending on the provided <a class="el" href="namespacepagmo_1_1util_1_1hv__algorithm.html" title="Hypervolume algorithm namespace. ">hv_algorithm</a>) than executing "exclusive" method in a loop.</p>
<p>This base method uses a very naive approach, which in fact is only slightly more efficient than calling "exclusive" method successively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>vector of fitness_vectors for which the contributions are computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_point</td><td>distinguished "reference point". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of exclusive contributions by every point </dd></dl>

<p>Reimplemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#accced537db47abbc014c330fa5a11c2a">pagmo::util::hv_algorithm::bf_fpras</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv3d.html#a0026145cbdf412b02092c9bb8276045e">pagmo::util::hv_algorithm::hv3d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1wfg.html#a7ce7ebf891a12fd0e0a6c82c64c70629">pagmo::util::hv_algorithm::wfg</a>, and <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv2d.html#a1c95eb7af15de34e9f92a6cea4616375">pagmo::util::hv_algorithm::hv2d</a>.</p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00199">199</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a765957fc1f45fe80210c16cb22bf0fcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pagmo::util::hv_algorithm::base::dom_cmp </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dominance comparison method. </p>
<p>Establishes the domination relationship between two points (overloaded for double*);</p>
<p>returns DOM_CMP_B_DOMINATES_A if point 'b' DOMINATES point 'a' returns DOM_CMP_A_DOMINATES_B if point 'a' DOMINATES point 'b' returns DOM_CMP_A_B_EQUAL if point 'a' IS EQUAL TO 'b' returns DOM_CMP_INCOMPARABLE otherwise </p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00320">320</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98d9f901aa45a780cb09f440642cb54e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pagmo::util::hv_algorithm::base::dom_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dim_bound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dominance comparison method. </p>
<p>Establishes the domination relationship between two points.</p>
<p>returns DOM_CMP_B_DOMINATES_A if point 'b' DOMINATES point 'a' returns DOM_CMP_A_DOMINATES_B if point 'a' DOMINATES point 'b' returns DOM_CMP_A_B_EQUAL if point 'a' IS EQUAL TO 'b' returns DOM_CMP_INCOMPARABLE otherwise </p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00285">285</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a230011c2b5274a2e20060cdb10fe2aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pagmo::util::hv_algorithm::base::exclusive </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>p_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exclusive hypervolume method. </p>
<p>This method computes the exclusive hypervolume for given individual. It accepts a list of points as an input, and the distinguished "reference point". Hypervolume is then computed as a joint hypervolume of hypercubes, generated pairwise with the reference point and each point from the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_idx</td><td>index of the individual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>vector of fitness_vectors for which the hypervolume is computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_point</td><td>distinguished "reference point".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exlusive hypervolume contributed by the individual at index p_idx </dd></dl>

<p>Reimplemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#a30db748f68b303da2f8a3e4c222906f2">pagmo::util::hv_algorithm::bf_fpras</a>.</p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00086">86</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44f32a88f43e2052cc5b9efe420c833a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pagmo::util::hv_algorithm::base::extreme_contributor </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(double, double)&#160;</td>
          <td class="paramname"><em>cmp_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the extreme contributor </p>
<p>Computes the index of the individual that contributes the most or the least to the hypervolume (depending on the prodivded comparison function) </p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00103">103</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08c3c236fe354e8c8b6c3547d9a0db60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pagmo::util::hv_algorithm::base::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get algorithm's name. </p>
<p>Default implementation will return the algorithm's mangled C++ name.</p>
<dl class="section return"><dt>Returns</dt><dd>name of the algorithm. </dd></dl>

<p>Reimplemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv4d.html#a381423f22326737cf3c5ea93d6d45fed">pagmo::util::hv_algorithm::hv4d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1fpl.html#aebba78bdc88f921e0300bd2c5d69b55d">pagmo::util::hv_algorithm::fpl</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hoy.html#a5771ab48aa0d7f438dbe6904efe2896d">pagmo::util::hv_algorithm::hoy</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#ad2d67cbece2b5b371d86d7e56ae653bb">pagmo::util::hv_algorithm::bf_fpras</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv3d.html#a2f77d3106f7b904b5f62f2c0ab18a13b">pagmo::util::hv_algorithm::hv3d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__approx.html#a996fec743082fbdd626f27bb282fb57f">pagmo::util::hv_algorithm::bf_approx</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1wfg.html#a2c6ba948a133c0c109e5fd8226eb49b1">pagmo::util::hv_algorithm::wfg</a>, and <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv2d.html#a57f68268e238b0f5ee959fe1c895f18c">pagmo::util::hv_algorithm::hv2d</a>.</p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00366">366</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6819dc695fb462804edc56aa48a28b34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pagmo::util::hv_algorithm::base::greatest_contributor </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greatest contributor method. </p>
<p>This method establishes the individual that contributes the most to the hypervolume. By default it computes each individual contribution, and chooses the one with the highest contribution. Other algorithms may overload this method for a more efficient solution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>vector of fitness_vectors for which the hypervolume is computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_point</td><td>distinguished "reference point".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the greatest contributor </dd></dl>

<p>Reimplemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#a96ba7d0fec4507cf437ed82dfd590ad2">pagmo::util::hv_algorithm::bf_fpras</a>, and <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__approx.html#a48c5908e568a7af9a2e92ce31cf9643c">pagmo::util::hv_algorithm::bf_approx</a>.</p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00182">182</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24e6e044ab111e4eeec6bfab750f5e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pagmo::util::hv_algorithm::base::least_contributor </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Least contributor method. </p>
<p>This method establishes the individual that contributes the least to the hypervolume. By default it computes each individual contribution, and chooses the one with the lowest contribution. Other algorithms may overload this method for a more efficient solution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>vector of fitness_vectors for which the hypervolume is computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_point</td><td>distinguished "reference point".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the least contributor </dd></dl>

<p>Reimplemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#a5aa1f874dda26bddfc1f6d1a7d607801">pagmo::util::hv_algorithm::bf_fpras</a>, and <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__approx.html#adac65141810efc171d316655cb42f8a2">pagmo::util::hv_algorithm::bf_approx</a>.</p>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00166">166</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfd91d67087f9d26a50c91e4fb35cac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pagmo::util::hv_algorithm::base::verify_before_compute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>r_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verification of input. </p>
<p>This method serves as a verification method. Not every algorithm is suited of every type of problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>- vector of fitness_vectors for which the hypervolume is computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_point</td><td>- distinguished "reference point". </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv4d.html#af5ba9929cf9323f58ed612d82b3f7d6d">pagmo::util::hv_algorithm::hv4d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1fpl.html#a1dfd6a0844546198745d1f7d06807908">pagmo::util::hv_algorithm::fpl</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hoy.html#a0f399478e02d2f5107a5a18e51c38ef4">pagmo::util::hv_algorithm::hoy</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__fpras.html#a5b5fe3d3b12468d267a294bc9180baa1">pagmo::util::hv_algorithm::bf_fpras</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv3d.html#a27f76338b97dee566c77c629b2f99042">pagmo::util::hv_algorithm::hv3d</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1bf__approx.html#a1bf27603772e0da8c0956943dd5fc5e8">pagmo::util::hv_algorithm::bf_approx</a>, <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1wfg.html#afc28244907ade3d8f01cee35bcd62183">pagmo::util::hv_algorithm::wfg</a>, and <a class="el" href="classpagmo_1_1util_1_1hv__algorithm_1_1hv2d.html#af0a9cdabc474ecf43fa7cc2b70dddc03">pagmo::util::hv_algorithm::hv2d</a>.</p>

</div>
</div>
<a class="anchor" id="a43087efbc5e82e07da068a5e7a94513c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pagmo::util::hv_algorithm::base::volume_between </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepagmo.html#a9d581d2201be7d5ecc1dc0c61d373ab8">fitness_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dim_bound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute volume between two points. </p>
<p>Calculates the volume between points a and b (as defined for n-dimensional Euclidean spaces).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first point defining the hypercube </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second point defining the hypercube </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_bound</td><td>dimension boundary for the volume. If equal to 0 (default value), then compute the volume of whole vector. Any positive number limits the computation from dimension 1 to dim_bound INCLUSIVE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume of hypercube defined by points a and b </dd></dl>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00245">245</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f9272bf3b4f1787e3278984e55291c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pagmo::util::hv_algorithm::base::volume_between </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute volume between two points. </p>
<p>Calculates the volume between points a and b (as defined for n-dimensional Euclidean spaces).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first point defining the hypercube </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second point defining the hypercube </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>dimension of the vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume of hypercube defined by points a and b </dd></dl>

<p>Definition at line <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html#l00267">267</a> of file <a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="util_2hv__algorithm_2base_8h_source.html">util/hv_algorithm/base.h</a></li>
<li><a class="el" href="util_2hv__algorithm_2base_8cpp_source.html">util/hv_algorithm/base.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
