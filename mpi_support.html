<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PaGMO: MPI support in PaGMO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PaGMO
   &#160;<span id="projectnumber">1.1.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">MPI support in PaGMO </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>PaGMO can be configured to use MPI to dispatch parallel optimisation instances to computers participating in a cluster.</p>
<dl class="section author"><dt>Author</dt><dd>Francesco Biscani (<a href="#" onclick="location.href='mai'+'lto:'+'blu'+'es'+'car'+'ni'+'@gm'+'ai'+'l.c'+'om'; return false;">blues<span style="display: none;">.nosp@m.</span>carn<span style="display: none;">.nosp@m.</span>i@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>) </dd>
<dd>
Dante Stroe (<a href="#" onclick="location.href='mai'+'lto:'+'dan'+'te'+'.st'+'ro'+'e@g'+'ma'+'il.'+'co'+'m'; return false;">dante<span style="display: none;">.nosp@m.</span>.str<span style="display: none;">.nosp@m.</span>oe@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a>)</dd></dl>
<h1><a class="anchor" id="mpi_requirements"></a>
Requirements</h1>
<p>In order to enable and use MPI support in PaGMO a standard-compliant MPI implementation (e.g., Open MPI, MPICH2, etc.) must be available on all systems participating to the cluster. PaGMO uses basic MPI 1.2 calls such as MPI_Recv, MPI_Send etc., and does not employ any function specific to MPI 2.x.</p>
<p>For best performance, the root node of the MPI cluster (i.e., the node where mpiexec/mpirun is launched) should have a thread-safe MPI implementation. This means that a call to MPI_Query_thread should ideally return MPI_THREAD_MULTIPLE. It is possible to run PaGMO also if MPI_Query_thread returns MPI_THREAD_SERIALIZED, but in this case there will be a performance penalty. With any lesser level of thread support in the root node, PaGMO will refuse to operate in MPI mode.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.fz-juelich.de/jsc/juropa/www3/MPI_Query_thread.html">http://www.fz-juelich.de/jsc/juropa/www3/MPI_Query_thread.html</a></dd></dl>
<p>In a PaGMO MPI cluster, problem, population and algorithm instances are sent from the master node to the slave nodes where the optimisation process takes place. In order for the objects to be sent over the network, they need to be serializable. Serialization for all classes shipped with PaGMO is already implemented. The writer of new PaGMO classes will need to make sure that her own classes are serializable.</p>
<p>Additionally, it must always kept in mind that when working with MPI each processor is living inside a separate process: aside from the objects serialized and dispatched around in the cluster, there is no other form of communication. For instance, problems or algorithms employing a shared memory state (e.g., static class members) must be carefully treated during serialization in order to provide to the remote processes all the information needed for the optimisation process. </p>
<h1><a class="anchor" id="mpi_compilation"></a>
Compilation</h1>
<p>In order to compile PaGMO with MPI support, just enable the ENABLE_MPI option in CMake. The build system should automatically detect your MPI implementation and configure the build accordingly. In case of issues, you can explictly specify the location of you MPI libraries and headers by manipulating the relevant CMake variables. </p>
<h1><a class="anchor" id="mpi_model"></a>
PaGMO's MPI model</h1>
<p>MPI support in PaGMO is implemented via the <a class="el" href="classpagmo_1_1mpi__island.html" title="MPI island class. ">pagmo::mpi_island</a> and <a class="el" href="classpagmo_1_1mpi__environment.html" title="MPI environment class. ">pagmo::mpi_environment</a> classes. The <a class="el" href="classpagmo_1_1mpi__environment.html" title="MPI environment class. ">pagmo::mpi_environment</a> class is used just for initialisation purposes, and an instance of it should be created at the very beginning of any MPI-enabled PaGMO main() function.</p>
<p>The <a class="el" href="classpagmo_1_1mpi__island.html" title="MPI island class. ">pagmo::mpi_island</a> class is an island class deriving from <a class="el" href="classpagmo_1_1base__island.html" title="Base island class. ">pagmo::base_island</a> that can be operated exactly like any other island class (e.g., <a class="el" href="classpagmo_1_1island.html" title="Local island class. ">pagmo::island</a>): it can be created and operated stand-alone, or inserted in a <a class="el" href="classpagmo_1_1archipelago.html" title="Archipelago class. ">pagmo::archipelago</a>. Different types of islands can exist in the same <a class="el" href="classpagmo_1_1archipelago.html" title="Archipelago class. ">pagmo::archipelago</a>, so that it is possible to mix MPI islands with islands of different kind.</p>
<p>At the beginning of a PaGMO MPI main() execution, a list of available processors is created. The list contains the integers from 1 to N - 1, where N is the size of the MPI world (from which it follows that it is not possible to use PaGMO with an MPI world of size less than 2). In the PaGMO model, the process with rank 0 is tasked with the dispatch and coordination of jobs and does not perform any optimization process.</p>
<p>Whenever an evolution method is called from from a <a class="el" href="classpagmo_1_1mpi__island.html" title="MPI island class. ">pagmo::mpi_island</a>, the island will check the list of available processors and, if a processor is available, will erase the processor ID from the list and dispatch the evolution to that processor. At the end of the evolution, the island retrieves the payload and adds the processor ID back to the list of available processors.</p>
<p>Whenever the number of MPI islands is at least equal to the MPI world size, it might happen that one or more islands are not able to acquire any processor at the beginning of the evolution, all the processors being busy. In such case a fair priority queue is created, and the islands waiting for a processor to be released are added to the end of the queue. Whenever a processor is released, the queue is notified and the first island in the queue acquires the processor and procedes as above. </p>
<h1><a class="anchor" id="mpi_example"></a>
MPI example</h1>
<p>The following simple example shows how to create and use MPI islands in a PaGMO C++ main(). </p><div class="fragment"><div class="line"><span class="comment">// Include the global PaGMO header.</span></div>
<div class="line"><span class="preprocessor">#include &quot;pagmo.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepagmo.html">pagmo</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// Initialise the MPI environment.</span></div>
<div class="line">        <a class="code" href="classpagmo_1_1mpi__environment.html">mpi_environment</a> env;</div>
<div class="line">        <span class="comment">// Create a problem and an algorithm.</span></div>
<div class="line">        <a class="code" href="classpagmo_1_1problem_1_1dejong.html">problem::dejong</a> prob(10);</div>
<div class="line">        <a class="code" href="classpagmo_1_1algorithm_1_1monte__carlo.html">algorithm::monte_carlo</a> algo(100);</div>
<div class="line">        <span class="comment">// Create an archipelago of 10 MPI islands.</span></div>
<div class="line">        <a class="code" href="classpagmo_1_1archipelago.html">archipelago</a> a;</div>
<div class="line">        a.<a class="code" href="classpagmo_1_1archipelago.html#a451b0548c3d0e9527522113b4e7e65e4">set_topology</a>(<a class="code" href="classpagmo_1_1topology_1_1ring.html">topology::ring</a>());</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i) {</div>
<div class="line">                a.<a class="code" href="classpagmo_1_1archipelago.html#acb12097eb5474f0ed5d834f635053abb">push_back</a>(<a class="code" href="classpagmo_1_1mpi__island.html">mpi_island</a>(algo,prob,1));</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Evolve the archipelago 10 times.</span></div>
<div class="line">        a.<a class="code" href="classpagmo_1_1archipelago.html#a41c00dc04ea5266436dfe4ec476a6200">evolve</a>(10);</div>
<div class="line">        a.<a class="code" href="classpagmo_1_1archipelago.html#a8498d524887c15b5863fb0d1095c04d4">join</a>();</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The code is exactly the same as it would be for use with <a class="el" href="classpagmo_1_1island.html" title="Local island class. ">pagmo::island</a> instances, the only difference being the creation of a <a class="el" href="classpagmo_1_1mpi__environment.html" title="MPI environment class. ">pagmo::mpi_environment</a> at the very beginning. </p>
<h1><a class="anchor" id="mpi_execution"></a>
Executing MPI programs</h1>
<p>An MPI-enabled PaGMO executable can be executed just like any MPI executable. The following instructions assume that the MPI environment is from Open MPI; different MPI implementations might need slightly different setup (e.g., MPICH2 requires a daemon to be running for dispatching MPI jobs). </p>
<h2><a class="anchor" id="local_mpi_execution"></a>
Local execution</h2>
<p>Local MPI execution is a simple way to verify that the MPI program is working correctly. As the name implies, all jobs will be started on the local machine.</p>
<p>Assuming the name of the executable is 'main', local MPI execution can be launched with: </p><pre class="fragment">$ mpiexec -n 10 ./main
</pre><p> where the argument to the </p><pre class="fragment">-n
</pre><p> parameter is the MPI world size (i.e., the number of MPI jobs that will be launched concurrently - in this case 10). </p>
<h2><a class="anchor" id="cluster_mpi_execution"></a>
Execution in a cluster</h2>
<p>Once it has been verified that local execution works as expected, the next step is to run the MPI-enabled PaGMO executable in a cluster. Again, the setup is the same needed for any MPI executable. Namely:</p>
<ul>
<li>exactly the same executable should be present on all nodes of the cluster;</li>
<li>the MPI executable should reside in the same path on all nodes;</li>
<li>any resource needed by the executable (e.g., files) should be available at the same location on all nodes.</li>
</ul>
<p>To run the executable on the cluster, a hostfile will be needed. A hostfile is a plain text file describing the machine participating in the cluster. A sample sample hostfile is the following: </p><pre class="fragment">sophia.estec.esa.int slots=8
ursula.estec.esa.int slots=8
</pre><p> For each line, the first entry is the name (or IP address) of a computer participating in the cluster, the second entry is the number of jobs that can be run on that machine. Typically the slots number will be equal to the number of CPUs on the computer.</p>
<p>Once the hostfile has been created, the MPI executable can be launched with the command: </p><pre class="fragment">$ mpiexec -n 10 -hostfile hfile.txt ./main
</pre><p> where hfile.txt is your hostfile. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
